#+OPTIONS: num:nil
This program was inspired by [[https://news.ycombinator.com/item?id=14156093][this vim plugin]] which when I looked at the Vimscript source code made me wonder about how complex roughly equivalent elsip would look. It was an adventure in learning regexes and Emacs =regexp= foo.

It also is an exploration in applying the /How to Design Programs/ methodology within org-mode using literate programming. There are some rough edges because the code will run in Emacs' significantly stateful context.
* Overview
** Purpose
 The script sorts a collection of Python =import= statements alphabetically using the specific name imported. It ignores the =from= prefix of the statement.

** Examples
 Suppose we have the following Python Source 
 #+NAME: example-program
 #+BEGIN_SRC python :tangle no
   import m
   import j
   from a import n
   from c import k
   from b import i

   def spam(a):
       return a

   spam(3)
 #+END_SRC

 Running the utility should modify the source to
 #+NAME: modified-example-program
 #+BEGIN_SRC python :tangle no
   from b import i
   import j
   from c import k
   import m
   from a import n

   def spam(a):
       return a

   spam(3)
 #+END_SRC

** Template
 1. Find lines containing import statements
 2. Parse lines to find the name of the import
 3. Sort lines based on name of import
 4. Replace old lines with sorted lines
 #+NAME: main
 #+BEGIN_SRC elisp :noweb tangle :tangle python-import-sort.el
   (defun python-import-sort ()
     (interactive)
     (fundamental-mode)
     (save-excursion
       (first-matching-line import-match)
       (let ((place-to-insert (point-marker))
             (whole-buffer (buffer-string)))
         (with-temp-buffer
           (fundamental-mode)
           <<edit-temp-buffer>>
           (setq whole-buffer (buffer string))); end with-temp-buffer
         <<edit-source-buffer>>)))

   ;;; Helpers

   <<search-helpers>>

   <<parse-helpers>>

   <<sort-helpers>>

   <<replace-helpers>>
 #+END_SRC
** Outline
7. Replace existing import statements
#+BEGIN_SRC elisp
  ;; delete the matching lines from original buffer
  (buffer-flush-matching-lines import-match)
  (insert whole-buffer)
#+END_SRC
8. End excursion
#+BEGIN_SRC elisp
    )) ; end let end excursion
  (normal-mode)
#+END_SRC
* TODO Edit Temp Buffer
* TODO Edit Source Buffer
* DONE Search Helpers
A collection of functions to facillitate searching a buffer and operating upon the buffer based on search.
#+NAME: search-helpers
#+BEGIN_SRC elisp :noweb-tangle
  ;;; Search Helpers

  <<import-match>>

  <<buffer-flush-matching-lines>>

  <<buffer-flush-not-matching-lines>>

  <<first-matching-line>>
#+END_SRC
** import-match 
#+NAME: import-match
#+BEGIN_SRC elisp
  ;;; The match string for flushing and keeping
  (setq import-match "import")
#+END_SRC
  + *Purpose*
    A constant for matching import statements. Here the value is a simple string but it could be a =regexp=.
** buffer-flush-matching-lines
#+NAME: buffer-flush-matching-lines
#+BEGIN_SRC elisp
  (defun buffer-flush-matching-lines (regex)
    "Flushes matching lines from buffer."
    (mark-whole-buffer)
    (flush-lines regex))
#+END_SRC
  + *Purpose*
    Purge/flush all lines from a buffer that match a =regexp=.
  + *Example*
    #+BEGIN_EXAMPLE
      Given a buffer containing.

        # Using spam
        import spam
        spam.eggs(4)
        print("eggs are tasty")
        spam.spam('spam')

      Calling buffer-flush-matching-lines("eggs") yields

        # a comment
        import spam
        spam.spam('spam')
#+END_EXAMPLE
** buffer-flush-not-matching-lines
#+NAME: buffer-flush-not-matching-lines
#+BEGIN_SRC elisp
  (defun buffer-flush-not-matching-lines (regex)
    "Removes non-matching lines from buffer."
      (mark-whole-buffer)
      (keep-lines regex))
#+END_SRC
  + *Purpose*
    Purge/flush all lines from a buffer that do not match a =regexp=.
  + *Example*
    #+BEGIN_EXAMPLE
      Given a buffer containing.

        # Using spam
        import spam
        spam.eggs(4)
        print("eggs are tasty")
        spam.spam('spam')

      Calling buffer-flush-not-matching-lines("eggs") yields

        spam.eggs(4)
        print("eggs are tasty")
#+END_EXAMPLE
** first-matching-line
#+NAME: first-matching-line
#+BEGIN_SRC elisp
  (defun first-matching-line (regex)
    "Finds the start of line for the first line matching regex."
    (beginning-of-buffer)
    (search-forward regex)
    (move-beginning-of-line nil))
#+END_SRC
  + *Purpose*
    Plase point at start of first line in buffer that contains match for =regexp=
  + *Example*
    #+BEGIN_EXAMPLE
      Given a buffer containing.

        # Using spam
        import spam
        spam.eggs(4)
        print("eggs are tasty")
        spam.spam('spam')

      Calling first-matching-line("eggs") moves the point to the beginning of

        spam.eggs(4)

    #+END_EXAMPLE
* TODO Parse Helpers
 Story
I spent a couple of hours (much longer than I expected) goofing around with elisp and regexp's to figure out a way to make string matching work. I am sure there is a simpler way.

The helper function =parse-import-statement= contains the final regex.
** Purpose
To create a data structure upon which the lines can be sorted.
** Data Structure
The data structure is a dotted list. The first element is the original line and the second element is the name of what is actually imported.
#+BEGIN_EXAMPLE
("from a import n" . "n")
#+END_EXAMPLE
** Examples
#+BEGIN_EXAMPLE lisp
  (parse-import-statements
    '("import m"
      "import j"
      "from a import n"
      "from c import k"
      "from b import i"))
  ; result
  '(("import m" . "m")
    ("import j" . "j")
    ("from a import n" . "n")
    ("from c import k" . "k")
    ("from b import i" . "i"))
#+END_EXAMPLE
** Template
#+NAME: parse-helpers
#+BEGIN_SRC elisp :noweb tangle
  ;;; Parse Helpers

  <<parse-import-statement>>

  <<parse-import-statements>>
#+END_SRC
** Helpers
The high level parsing function:
#+NAME: parse-import-statements
#+BEGIN_SRC elisp
  (defun parse-import-statements (statements &optional a-list)
    "Parses each statement in statements. Returns a list of (statement . sort-term)."
    (if (null statements)
        a-list
      (parse-import-statements
       (rest statements)
       (cons (parse-import-statement (first statements))
             a-list))))
#+END_SRC
Parse one import statement
#+NAME: parse-import-statement
#+BEGIN_SRC elisp
  (defun parse-import-statement (line)
    "Takes a Python import statement as a string.
  Returns a dotted list of: (import-statement . sort-term)."
    (let* ((matcher "\\(\\w+ import \\|import \\)\\(\\w\\)")
           (match (string-match matcher line)))
      (cons line (match-string 2 line))))
#+END_SRC
*** TODO provide flexibility in matching white space
Currently, only a single space between =import= and the name is matched.
* TODO Sort Helpers
** Data Structure
The data structure is a dotted list. The first element is the original line and the second element is the name of the python module to be imported.
#+BEGIN_EXAMPLE
("from a import n" . "n")
#+END_EXAMPLE
** Template
#+NAME: sort-lines-based-on-name-of-import
#+BEGIN_SRC elisp :noweb tangle :tangle yes
  ;;; sort lines based on name of import

  <<python-module-less-than>>

  <<sort-python-modules>>
#+END_SRC
** Helpers
*** python-module-less-than
Compare two data structures based on second element which is the name of the python module.
#+NAME: python-module-less-than
#+BEGIN_SRC elisp
  ;;; sorting helper
  (defun python-module-less-than (lhs rhs)
    "Returns true if the module name of the left hand side is less than the module name of the right hand side."
    (string< (second lhs) (second rhs)))
#+END_SRC
*** sort-python-modules
Sort data structures based on second element which is the name of the module.
#+NAME: sort-python-modules
#+BEGIN_SRC elisp
  ;;; sorting helper
  (defun sort-python-modules (structures)
    "Sorts data structures using data-structure-less-than"
    (sort structures python-module-less-than))
#+END_SRC
* TODO Replace old lines with sorted lines
** Helpers
*** insert-python-import-statement
Insert data structure string.
#+NAME: insert-python-import-statement
#+BEGIN_SRC elisp
  (defun insert-python-import-statement (ds)
    "Inserts the string (car) of a data structure into current buffer"
    (insert (car ds))
    (newline))
#+END_SRC
*** insert-python-import-statements
Insert strings from all data structures. Uses =mapc= instead of =mapcar= because it is called for side-effects.
#+NAME: insert-python-import-statements
#+BEGIN_SRC elisp
  (defun insert-python-import-statements (structures)
    "Inserts the ordered statements into current buffer."
    (mapc insert-python-import-statement structures))
#+END_SRC

* Notes
** Emacs
Some useful emacs commands including
1. =M-x keep-lines=
2. =M-x flush-lines=
Some useful elisp:
1. =string-match= to 'compile' a regex against a string.
2. =match-string= to extract the groups of a match. These are used in the =parse-import-statement=.
** HTDP
The template for writing code using the HTDP recipes is recursive. From the overall high level program down toward each function we have:
1. Purpose
2. Examples
3. Template
4. Tests (hopefully)
5. Implementation (sometimes)
6. Helpers

In the literate programming model the template may be mostly a =noweb= construct. The helpers are there as a short circuit of the recursive structure.
** TODO write elisp code to create an HTDP outline from the template.
